---

# project information
project_name: sealskin
project_url: "https://github.com/selkies-project/sealskin/"
project_logo: "https://raw.githubusercontent.com/linuxserver/docker-templates/master/linuxserver.io/img/selkies-logo.png"
project_blurb: "[Sealskin]({{ project_url }}) is a self-hosted, client-server platform that enables users to run powerful, containerized desktop applications streamed directly to a web browser. It uses a browser extension to intercept user actionsâ€”such as clicking a link or downloading a file and redirects them to a secure, isolated application environment running on a remote server."
project_lsio_github_repo_url: "https://github.com/linuxserver/docker-{{ project_name }}"
project_categories: "Remote Desktop, Business"
# supported architectures
available_architectures:
  - {arch: "{{ arch_x86_64 }}", tag: "amd64-latest"}
  - {arch: "{{ arch_arm64 }}", tag: "arm64v8-latest"}
# container parameters
param_container_name: "{{ project_name }}"
param_usage_include_vols: true
param_volumes:
  - {vol_path: "/config", vol_host_path: "/path/to/{{ project_name }}/config", desc: "All configuration files and metadata for the application."}
  - {vol_path: "/storage", vol_host_path: "/path/to/{{ project_name }}/storage", desc: "All file storage for home directories and ephemeral mounts."}
  - {vol_path: "/var/run/docker.sock", vol_host_path: "/var/run/docker.sock", desc: "Docker socket, required to spin up application containers."}
param_usage_include_ports: true
param_ports:
  - {external_port: "8443", internal_port: "8443", port_desc: "HTTPS Sessions and API communication port."}
opt_param_usage_include_ports: true
opt_param_ports:
  - {external_port: "8000", internal_port: "8000", port_desc: "HTTP Fallback API communication port."}
opt_param_usage_include_env: true
opt_param_env_vars:
  - {env_var: "HOST_URL", env_value: "IP or subdomain.doman.com", desc: "On initial setup this will be used to fill in the default admin configuration file in the `/config` directory, if unset the string HOST_URL will need to be replaced."}
# application setup block
app_setup_block_enabled: true
app_setup_block: |
  This image hosts the server component for the SealSkin platform.

  Download the browser extension from [for Chrome HERE](https://chromewebstore.google.com/detail/sealskin-isolation/lclgfmnljgacfdpmmmjmfpdelndbbfhk), [for Firefox HERE](https://addons.mozilla.org/en-US/firefox/addon/sealskin-isolation/).

  On first init a file will be created `/config/admin.json` if you set `HOST_URL` you can use this file for credentials as is, if you did not you will need to edit it and change the URL/IP set in the file to use it. Once authenticated in the extension you can generate users and new config files to distribute or use.

  >[!NOTE]
  >If you are not using a legitimate ssl certificate (default self signed in `/config/ssl`) than you can only use the Chrome extension and must forward whatever port mapped to 8000 to the internet. Firefox enforces https in the extension space and Chrome allows us to fall back to E2EE over http.

  >[!NOTE]
  >Please remember to copy and delete the default `/config/admin.json` file from your server for security, keep it somewhere safe!

  ## Basic Requirements

  It is important to use the container name `sealskin` as this is how the container identifies itself and determines its ports, volumes, and network. The only backend provider to launch containers is Docker. The storage paths are required for key and storage management while their mount paths are adapted from within the container to be run on the host for launched sessions. Everyting in the stack runs as the PUID and PGID down to the container desktop sessions, it is important that the user you use has access to the `/config` and `/storage` paths.

  ### NVIDIA Support

  Nvidia support only works on 580 and up full proprietary drivers (no MIT/GPL) with `nvidia-drm.modeset=1` kernel parameter set. You must ensure the card is initialized before running a container so on headless systems run `nvidia-modprobe --modeset` from the host even with this kernel parameter set, this only needs to be run once per boot on headless systems.

  ## Key & Certificate Management

  The server requires several cryptographic keys to function. You can either let the server perform an automatic setup on its first run or manually provide your own keys for more control.

  ### Automatic First-Run Setup (Recommended)

  This is the simplest method. On the first launch with an empty `/config` volume:

  1.  An init process automatically generates the mandatory server key (`server_key.pem`) and a self-signed SSL certificate for the proxy (`proxy_key.pem`, `proxy_cert.pem`).
  2.  The application will then detect that no administrator exists, create a default user named `admin`, and output a configuration file admin.json into the `/config/` directory.

  Your only action is if the `HOST_URL` environment variable is not set to replace the `HOST_URL` string in the file with your IP/URL.

  ### Manual Pre-Configuration (Advanced)

  If you wish to use your own administrator key or provide a valid SSL certificate, you can place the necessary files in the `/config` volume **before** the first launch.

  *   **To use a custom Admin Key:**
      1.  Generate your own RSA keypair.
      2.  Create a file containing only your **public key** PEM data at the following location:
          *   **Path:** `/path/to/config/.config/sealskin/keys/admins/admin`
      3.  The server will detect this file and skip the automatic admin creation. You will use your corresponding private key to log in from the extension.

  *   **To use a custom SSL Certificate:**
      *   Place your SSL private key and certificate file at these locations. This will override the self-signed certificate generated by the init process.
          *   **Key Path:** `/path/to/config/ssl/proxy_key.pem`
          *   **Cert Path:** `/path/to/config/ssl/proxy_cert.pem`

  *   **To use a custom Server E2EE Key:**
      *   Place your RSA private key at this location. This is the core key for the API's end-to-end encryption and validates the server when a user sets the servers public key when configuring the extension.
          *   **Path:** `/path/to/config/ssl/server_key.pem`
          *   **Generation Command:** `openssl genpkey -algorithm RSA -out /path/to/config/ssl/server_key.pem -pkeyopt rsa_keygen_bits:4096`
      *   To obtain the corresponding public key (which is needed by the browser extension), you can extract it from your private key with this command:
          *   **Extraction Command:** `openssl rsa -in server_key.pem -pubout`
# init diagram
init_diagram: |
  "sealskin:latest": {
    docker-mods
    base {
      fix-attr +\nlegacy cont-init
    }
    docker-mods -> base
    legacy-services
    custom services
    init-services -> legacy-services
    init-services -> custom services
    custom services -> legacy-services
    legacy-services -> ci-service-check
    init-migrations -> init-adduser
    init-os-end -> init-config
    init-config -> init-config-end
    init-crontab-config -> init-config-end
    init-sealskin -> init-config-end
    init-config -> init-crontab-config
    init-mods-end -> init-custom-files
    init-adduser -> init-device-perms
    base -> init-envfile
    base -> init-migrations
    init-config-end -> init-mods
    init-mods-package-install -> init-mods-end
    init-mods -> init-mods-package-install
    init-adduser -> init-os-end
    init-device-perms -> init-os-end
    init-envfile -> init-os-end
    init-config -> init-sealskin
    init-custom-files -> init-services
    init-services -> svc-cron
    svc-cron -> legacy-services
    init-services -> svc-sealskin
    svc-sealskin -> legacy-services
  }
  Base Images: {
    "baseimage-alpine:3.22"
  }
  "sealskin:latest" <- Base Images
# changelog
changelogs:
  - {date: "19.01.26:", desc: "Fix init race condition."}
  - {date: "17.01.26:", desc: "Update docs to remove network and port requirement, add link to Firefox add on."}
  - {date: "08.01.26:", desc: "Improve permission fixing."}
  - {date: "31.10.25:", desc: "Initial Release."}
